# Gu√≠a de Desarrollo: Robots vs. Monstruos (Examen MIA-103)
Este plan est√° dise√±ado para que construyas la simulaci√≥n de forma ordenada, desde la base (el mundo) hasta la inteligencia de los agentes.

**Paso 1: Construir el Mundo (La Clase Entorno)**
Antes de tener robots o monstruos, necesitas un lugar donde puedan existir.

- **Crea una clase Entorno:**
    - **__init__(self, N, p_free, p_soft):** El constructor debe crear el mundo.
        - Usa una lista de listas de listas en Python, o mejor a√∫n, un array de 3 dimensiones de NumPy (np.zeros((N, N, N))) para representar el espacio de N¬≥ cubos.
        - Rellena el espacio aleatoriamente seg√∫n los porcentajes p_free y p_soft. Puedes asignar n√∫meros para cada tipo de zona: 0 para libre, 1 para vac√≠a.
        - Guarda tambi√©n una lista para los robots y otra para los monstruos que existir√°n en el entorno.
    - **M√©todos √∫tiles:**
        - agregar_entidad(self, entidad, posicion): Para colocar un robot o monstruo en una posici√≥n inicial aleatoria (y libre).
        - es_valida(self, posicion): Para verificar si una coordenada (x, y, z) est√° dentro de los l√≠mites y no es una "Zona Vac√≠a".
        - obtener_estado(self, posicion): Devuelve qu√© hay en una coordenada espec√≠fica.
        - visualizar_compacto(self): M√©todo que muestra tres vistas ortogonales (XY, XZ, YZ) del cubo 3D para visualizaci√≥n completa.

**Paso 2: Crear al Agente Simple (La Clase Monstruo)**

- **Crea una clase Monstruo:**
    - **__init__(self, posicion_inicial, K=3):** Necesita su posici√≥n y K (frecuencia de movimiento, por defecto cada 3 iteraciones).
    - **actuar(self, entorno, k_iteracion_actual):** Este es su "cerebro".
        - Recibe el entorno para poder "ver" a su alrededor.
        - Cada K iteraciones (if k_iteracion_actual % K == 0:), el monstruo intenta moverse.
        - Elige una de las 6 direcciones adyacentes al azar.
        - Usa el m√©todo entorno.es_valida() para ver si se puede mover ah√≠.
        - Si puede, actualiza su propia posici√≥n.
    - **Propiedad especial:** Los monstruos irradian energ√≠a en su entorno inmediato (6 lados), detectable por el Monstroscopio.

**Paso 3: Construir al Agente Inteligente (La Clase Robot)**

- **Crea una clase Robot:**
    1. **__init__(self, posicion_inicial, orientacion_inicial):** Necesita su posici√≥n y su orientaci√≥n (vector como (1, 0, 0) para "adelante en X").
    2. **Atributos importantes:**
        - memoria: Lista para guardar experiencias (tiempo, percepcion, accion).
        - orientacion: Vector que define hacia d√≥nde "mira" el robot (su frente).
        - direccion_movimiento: Direcci√≥n actual de movimiento (puede diferir de orientaci√≥n).
        - choco_pared_anterior: Flag para el Vacuscopio.
        - destruido: Estado de destrucci√≥n del robot.

- **Implementa los Sensores (como m√©todos):**
    1. **percibir_entorno(self, entorno):** M√©todo principal que llama a todos los sensores.
        - **Giroscopio:** Conoce su orientaci√≥n actual.
        - **Monstroscopio:** Detecta energ√≠a irradiada por monstruos en las 5 celdas adyacentes (excluyendo la trasera seg√∫n orientaci√≥n).
        - **Vacuscopio:** Se activa despu√©s de un movimiento fallido (detecta obst√°culos).
        - **Energ√≥metro espectral:** Detecta monstruos directamente en la celda actual.
        - **Roboscanner:** Detecta robots en la celda de enfrente seg√∫n orientaci√≥n.
    2. Devuelve un diccionario con todas las percepciones: {"monstruo_cerca": True, "monstruo_actual": False, "robot_enfrente": False, ...}.

- **Implementa los Efectores (como m√©todos):**
    1. **mover_adelante(self, entorno):** Se mueve seg√∫n su orientaci√≥n actual.
        - Calcula nueva posici√≥n basada en orientaci√≥n.
        - Puede moverse a celdas libres (0) o con monstruos (3).
        - Si falla, activa el Vacuscopio para la siguiente iteraci√≥n.
    2. **rotar(self, eje, angulo):** Cambia su orientaci√≥n en ejes globales (X, Y, Z).
        - Actualiza tanto orientacion como direccion_movimiento.
    3. **usar_vacuumator(self, entorno):** Arma de destrucci√≥n final.
        - Requiere validaciones de seguridad.
        - Destruye monstruo en celda actual.
        - Autodestruye el robot.
        - Convierte la celda en Zona Vac√≠a (obst√°culo).

- **Implementa el Cerebro con Tres Modos de Operaci√≥n:**
    El m√©todo **decidir_y_actuar(self, entorno, tiempo)** implementa una jerarqu√≠a de modos:

    1. **üí• MODO ATAQUE (M√°xima Prioridad):**
        - Se activa cuando `monstruo_actual` es True.
        - Ejecuta la secuencia completa de destrucci√≥n:
            - ‚úÖ Paso 1: INGRESAR al cubo del monstruo (ya completado)
            - ‚úÖ Paso 2: DETECTAR con Energ√≥metro espectral (ya completado)
            - üöÄ Paso 3: ACTIVAR Vacuumator
        - Resultado: Robot y monstruo destruidos, celda convertida en Zona Vac√≠a.

    2. **üéØ MODO CAZA (Alta Prioridad):**
        - Se activa cuando `monstruo_cerca` es True (energ√≠a irradiada detectada).
        - Implementa persecuci√≥n inteligente:
            - Encuentra el monstruo m√°s cercano usando distancia Manhattan.
            - Calcula direcci√≥n hacia el monstruo.
            - Intenta moverse directamente hacia √©l.
            - Si no puede moverse, reorienta hacia el monstruo.
        - Permite movimiento hacia celdas ocupadas por monstruos.

    3. **üîç MODO EXPLORACI√ìN (Prioridad por Defecto):**
        - Se activa cuando no hay monstruos detectados.
        - Implementa exploraci√≥n b√°sica:
            - Intenta moverse hacia adelante.
            - Si encuentra obst√°culo, rota para cambiar direcci√≥n.
            - Usa memoria del Vacuscopio para evitar bucles.

- **Sistema de Memoria y Aprendizaje:**
    - Guarda cada experiencia: (tiempo, percepcion, accion).
    - Consulta memoria antes de decisiones cr√≠ticas.
    - Implementa jerarqu√≠a de reglas basada en experiencias pasadas.

**Paso 4: El Simulador (El Bucle Principal)**
Este es el script que une todo.

1. Crea una instancia del Entorno con par√°metros configurables.
2. Crea N robots y M monstruos y a√±√°delos al entorno en posiciones aleatorias.
3. Inicia un bucle principal: for t in range(max_iteraciones):
    - Dentro del bucle, recorre tu lista de robots y llama a robot.decidir_y_actuar(entorno, t).
    - Recorre tu lista de monstruos y llama a monstruo.actuar(entorno, t).
    - Actualiza el estado del entorno (elimina entidades destruidas).
    - Llama a entorno.visualizar_compacto() para ver el estado.
    - time.sleep(1) para control de velocidad.

**Paso 5: Visualizaci√≥n 3D (Opcional pero Recomendado)**
- Implementa visualizaci√≥n 3D usando matplotlib.
- Muestra robots con vectores de orientaci√≥n.
- Muestra monstruos con energ√≠a irradiada (cubos verdes suaves).
- Incluye leyenda detallada con emojis.
- Permite seguimiento en tiempo real de la simulaci√≥n.

**Caracter√≠sticas Implementadas:**
- ‚úÖ Distinci√≥n clara entre orientaci√≥n y direcci√≥n de movimiento.
- ‚úÖ Sistema de sensores completo y realista.
- ‚úÖ Tres modos de operaci√≥n con jerarqu√≠a de prioridades.
- ‚úÖ Persecuci√≥n inteligente de monstruos.
- ‚úÖ Sistema de destrucci√≥n completo (Vacuumator).
- ‚úÖ Memoria y aprendizaje b√°sico.
- ‚úÖ Visualizaci√≥n 2D compacta y 3D completa.
- ‚úÖ Manejo de obst√°culos y zonas vac√≠as.
- ‚úÖ Frecuencias de movimiento diferenciadas (robots: 100%, monstruos: 33%).
